package qgddfe;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
//import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.utils.Bits;

/**
@brief ????????????
@return ??????????
*/
public class MemCommGeneratorKernel extends Kernel {


	


/**
@brief ????????????
@return ??????????
*/
	public MemCommGeneratorKernel(final KernelParameters parameters, int send_interrupt_signal, int first_iteration_zero_offset, int burstCountOneShot) {
		super(parameters);

		DFEVar IterationNum = io.scalarInput("IterationNum", dfeUInt(16) );		
		DFEVar burstNum = io.scalarInput("burstNum", dfeUInt(32) );
		DFEVar chunkNum = io.scalarInput("chunkNum",  dfeUInt(8)); // number of chunks in one burst
		DFEVar addrOffset = io.scalarInput("addrOffset", dfeUInt(32) );	


		SMIO MCGSM = addStateMachine("MCG", new MemCommandGenStateMachine( this, burstCountOneShot));
		MCGSM.connectInput("chunkNum", chunkNum);
		MCGSM.connectInput("burstNum", burstNum);
		MCGSM.connectInput("IterationNum", IterationNum);

		DFEVar burstCount        = MCGSM.getOutput("burstCount");
		DFEVar issueMemCommand   = MCGSM.getOutput("issueMemCommand");
		DFEVar iterationCounter   = MCGSM.getOutput("iterationCounter");
//debug.simPrintf("split signal: %d, %d, %d\n", burstCount, burstNum, iterationCounter);
		issueMemCommand = optimization.pipeline( issueMemCommand);
		issueMemCommand = optimization.pipeline( issueMemCommand);
		issueMemCommand = optimization.pipeline( issueMemCommand);

		DFEVar MemAddr = burstCount;
		MemAddr = optimization.pipeline( MemAddr );
		MemAddr = optimization.pipeline( MemAddr );
		//MemAddr = optimization.pipeline( MemAddr );


		DFEVar burstNum_remained    = burstNum - burstCount;		

		
		DFEVar interruptSignal;
		if ( send_interrupt_signal == 1 ) {
			interruptSignal = (burstNum_remained <= burstCountOneShot) & (iterationCounter === IterationNum); 
		}
		else {
			interruptSignal = constant.var(dfeUInt(1), 0);
		}
		DFEVar burstNum_remained8 = burstNum_remained.cast( dfeUInt(8) );
		burstNum_remained8 = optimization.pipeline( burstNum_remained8 );
		DFEVar burstNum2issue  = (burstNum_remained <= burstCountOneShot) ? burstNum_remained8 : constant.var(dfeUInt(8), burstCountOneShot);

		interruptSignal = optimization.pipeline( interruptSignal );

		// creating custom memory controller
		DFEStruct cmdStream = LMemCommandStream.getLMemCommandDFEStructType().newInstance(this);


		Bits one = new Bits(15);
		one.setBit (0, 1);
		one.setOthers(0);

		DFEVar dynAddrOffset      = dfeUInt(32).newInstance(this);
		DFEVar addTodynAddrOffset = iterationCounter === 1 ? addrOffset : constant.var( dfeUInt(32), 0.0);
		optimization.pushNoPipelining();
		DFEVar prevdynAddrOffset = iterationCounter === 1 ? constant.var( dfeUInt(32), 0.0) : stream.offset(dynAddrOffset,-1);
		optimization.pushNoPipelining();

		dynAddrOffset <== prevdynAddrOffset + addTodynAddrOffset;

		
		if (first_iteration_zero_offset == 1) {
			MemAddr = (iterationCounter === 1) ? MemAddr : dynAddrOffset + MemAddr;
			optimization.pushNoPipelining();
		} 
		else {
			MemAddr = dynAddrOffset + MemAddr;
		}

//debug.simPrintf("Mem Addr: %d\n", MemAddr);

		cmdStream["address"] = MemAddr;
		cmdStream["size"] = burstNum2issue;
		cmdStream["inc"] = constant.var(dfeInt(8), 1);
		cmdStream["stream"] = constant.var(dfeRawBits(15), one);
		cmdStream["tag"] = interruptSignal;//constant.var(true);


		LMemCommandStream.makeKernelOutput("cmdStream", issueMemCommand, cmdStream);

	}

}
