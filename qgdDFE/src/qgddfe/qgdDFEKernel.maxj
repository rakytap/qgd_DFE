package qgddfe;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplexType;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

import java.util.ArrayList;
import java.util.List;

/**
@brief ????????????
@return ??????????
*/
public class qgdDFEKernel extends Kernel {

	DFEType dataTypeFix32            = dfeFixOffset(32, -30, SignMode.TWOSCOMPLEMENT);
	DFEType parameterTypeFix32       = dfeFixOffset(32, -25, SignMode.TWOSCOMPLEMENT);
	DFEComplexType cplxTypeFix32     = new DFEComplexType(dataTypeFix32);

	DFEVectorType<DFEComplex> kernelMatrixType = new DFEVectorType<DFEComplex>(cplxTypeFix32, 4);


/**
@brief ????????????
@return ??????????
*/
	// class to store elementary data of a gate operation
	class GateKernelStructType extends DFEStructType {
		GateKernelStructType() {
			super(sft ( "KernelMatrix", kernelMatrixType ),
			sft("TargetQubit", dfeUInt(4)),
			sft ( "ControlQubit", dfeUInt(4)),
			sft ( "GateType", dfeUInt(8)),
			sft ( "deriv", dfeUInt(3)));
		}
	}

	GateKernelStructType DFEstructType = new GateKernelStructType();


/**
@brief ????????????
@return ??????????
*/
	DFEVar shiftLeft(long value, DFEVar shift, int bits ) {

		List<DFEVar> values = new ArrayList<DFEVar>();

		KernelBase<?> base = shift.getOwner();

		for (int i = 0; i < bits; i++) {

			values.add(base.constant.var(KernelBase.dfeUInt(bits), value << i));

		}

        	return base.control.mux(shift, values);

	}


/**
@brief ????????????
@return ??????????
*/
	public qgdDFEKernel(final KernelParameters parameters, int dimMax) {
		super(parameters);

		// Input
		final DFEComplex x = io.input("x", cplxTypeFix32);

		DFEVar dim          = io.scalarInput("dim", dfeUInt(11) );


		DFEVar inputControllerCounter = control.count.simpleCounter(32);
		final DFEStruct gate = io.input("gates", DFEstructType, inputControllerCounter===0);

		DFEVar controlQubit = gate["ControlQubit"];
		DFEVar targetQubit  = gate["TargetQubit"];

		DFEVar indexStepControl = shiftLeft( 1, controlQubit, 11 ); // will need for controlled gates
		DFEVar indexStepTarget = shiftLeft( 1, targetQubit, 11 );
//debug.simPrintf("target : %d, %d\n", targetQubit, indexStepTarget);
//debug.simPrintf("control : %d, %d\n", controlQubit, indexStepControl);


		SMIO IndexGenSM = addStateMachine("IndexGenSM", new IndexGenStateMachine( this));
		IndexGenSM.connectInput("indexStepTarget", indexStepTarget);
		IndexGenSM.connectInput("dim", dim);

DFEVar indexCounter        = IndexGenSM.getOutput("indexCounter"); // will need for controlled gates
DFEVar targetState         = IndexGenSM.getOutput("targetState");

DFEVar indexCounterPair    = targetState ? -indexStepTarget.cast(dfeInt(11)) : indexStepTarget.cast(dfeInt(11));//IndexGenSM.getOutput("indexCounterPair");
for ( int idx=0; idx<12; idx++ ) {
	targetState = optimization.pipeline( targetState );
}

//debug.simPrintf("indexCounters: %d, %d, target state: %d, indexStepTarget: %d\n", indexCounter, indexCounterPair, targetState, indexStepTarget);
//debug.simPrintf("indexCounters: %d\n", indexCounterPair);

		DFEComplex x_offset = stream.offset(x, indexCounterPair, -dimMax/2, dimMax/2);


		DFEVector<DFEComplex> kernelMatrix = gate["KernelMatrix"];
//debug.simPrintf("kernelMatrix: %f, %f\n", kernelMatrix[3].getReal(), kernelMatrix[3].getReal());		

 		//DFEVar sqrt2_over_2 = constant.var( dataTypeFix32, 0.707106781); // sqrt(2)/2

                // if targetState === 1 than .... otherwise .... 
		DFEComplex y = targetState ?  x_offset*kernelMatrix[2] + x*kernelMatrix[3] : x*kernelMatrix[0] + x_offset*kernelMatrix[1];
//debug.simPrintf("elements: %f, %f\n", x.getReal(), y.getReal());


		// Output
		io.output("y", y, cplxTypeFix32);
	}

}
