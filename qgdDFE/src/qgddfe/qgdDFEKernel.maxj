package qgddfe;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplexType;
import com.maxeler.maxcompiler.v2.kernelcompiler.SMIO;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;

import java.util.ArrayList;
import java.util.List;

/**
@brief ????????????
@return ??????????
*/
public class qgdDFEKernel extends Kernel {

	DFEType dataTypeFix32            = dfeFixOffset(32, -30, SignMode.TWOSCOMPLEMENT);
	DFEType dataTypeFix64            = dfeFixOffset(64, -30, SignMode.TWOSCOMPLEMENT);
	DFEType parameterTypeFix32       = dfeFixOffset(32, -25, SignMode.TWOSCOMPLEMENT);
	DFEComplexType cplxTypeFix32     = new DFEComplexType(dataTypeFix32);

	DFEVectorType<DFEComplex> kernelMatrixType = new DFEVectorType<DFEComplex>(cplxTypeFix32, 4);


/**
@brief ????????????
@return ??????????
*/
	// class to store elementary data of a gate operation
	class GateKernelStructType extends DFEStructType {
		GateKernelStructType() {
			super(sft ( "KernelMatrix", kernelMatrixType ),
			sft("TargetQubit", dfeUInt(4)),
			sft ( "ControlQubit", dfeInt(5)),
			sft ( "deriv", dfeUInt(1)));
		}
	}

	GateKernelStructType DFEstructType = new GateKernelStructType();


/**
@brief ????????????
@return ??????????
*/
	DFEVar shiftLeft(long value, DFEVar shift, int bits ) {

		List<DFEVar> values = new ArrayList<DFEVar>();

		KernelBase<?> base = shift.getOwner();

		for (int i = 0; i < bits; i++) {

			values.add(base.constant.var(KernelBase.dfeUInt(bits), value << i));

		}

        	return base.control.mux(shift, values);

	}


/**
@brief ????????????
@return ??????????
*/
	public qgdDFEKernel(final KernelParameters parameters, int dimMax, int gates_num, boolean calcTrace, boolean verbose) {
		super(parameters);
		

		// Input
		DFEComplex x = io.input("x", cplxTypeFix32);

		DFEVar dim          = io.scalarInput("dim", dfeUInt(11) );
		DFEVar elementNum   = io.scalarInput("elementNum", dfeUInt(32) );
		
		DFEVar inputControllerCounter = control.count.simpleCounter(32, elementNum);
		DFEVar inputController = inputControllerCounter < gates_num;
		
		DFEStruct gate_input = io.input("gates", DFEstructType, inputController);
		
gate_input = optimization.limitFanout(gate_input, 10);		
		
List<DFEStruct> gate_list = new ArrayList<DFEStruct>();
for (int gate_idx=0; gate_idx<gates_num; gate_idx++) {
	gate_list.add( Reductions.streamHold(stream.offset(gate_input, gate_idx), inputControllerCounter === 0) );
}	

		

for (int gate_idx=0; gate_idx<gates_num; gate_idx++) {

	DFEStruct gate = gate_list[gate_idx];
//debug.simPrintf("gate_idx: %d, elements a: %f\n", gate_idx, x.getReal());

		DFEVar controlQubit = gate["ControlQubit"];
		DFEVar targetQubit  = gate["TargetQubit"];

		DFEVar useControlQubit = controlQubit >= 0;

		DFEVar indexStepControl = useControlQubit ? shiftLeft( 1, controlQubit.cast(dfeUInt(4)), 11 ) : constant.var( dfeUInt(11), 0); // will need for controlled gates
		DFEVar indexStepTarget = shiftLeft( 1, targetQubit, 11 );
//debug.simPrintf("gate_idx: %d, %d, target :%d, %d\n", gate_idx, inputControllerCounter, targetQubit, indexStepTarget);
//debug.simPrintf("control : %d, %d\n", controlQubit, indexStepControl);


		SMIO IndexGenSM = addStateMachine("IndexGenSM_"+String.valueOf(gate_idx), new IndexGenStateMachine( this));
		IndexGenSM.connectInput("indexStepTarget", indexStepTarget);
		IndexGenSM.connectInput("dim", dim-1);

		DFEVar indexCounter        = IndexGenSM.getOutput("indexCounter"); // will need for controlled gates
		DFEVar targetState         = IndexGenSM.getOutput("targetState");

		DFEVar indexCounterPair    = targetState ? -indexStepTarget.cast(dfeInt(11)) : indexStepTarget.cast(dfeInt(11));//IndexGenSM.getOutput("indexCounterPair");
for ( int idx=0; idx<12; idx++ ) {
	targetState = optimization.pipeline( targetState );
}

//debug.simPrintf("indexCounters: %d, %d, target state: %d, indexStepTarget: %d\n", indexCounter, indexCounterPair, targetState, indexStepTarget);
//debug.simPrintf("indexCounters: %d\n", indexCounterPair);

		DFEComplex x_offset = stream.offset(x, indexCounterPair, -dimMax/2, dimMax/2);


		DFEVector<DFEComplex> kernelMatrix = gate["KernelMatrix"];
//debug.simPrintf("kernelMatrix: %f, %f\n", kernelMatrix[3].getReal(), kernelMatrix[3].getReal());		

 		//DFEVar sqrt2_over_2 = constant.var( dataTypeFix32, 0.707106781); // sqrt(2)/2

                // if targetState === 1 than .... otherwise .... 


//debug.simPrintf("gate_idx: %d, elements b: %f\n", gate_idx, x.getReal());

		// multiplex inputs to save 50 of DSPs
		//DFEComplex transformedAmplitude = (targetState) ?  x_offset*kernelMatrix[2] + x*kernelMatrix[3] : x*kernelMatrix[0] + x_offset*kernelMatrix[1];
		DFEComplex amp_x = (targetState) ? kernelMatrix[3] : kernelMatrix[0];
		DFEComplex amp_x_offset = (targetState) ? kernelMatrix[2] : kernelMatrix[1];
		DFEComplex transformedAmplitude = x_offset*amp_x_offset + x*amp_x;



		DFEVar ControlQubitState = useControlQubit ? ((indexStepControl & indexCounter) > 0) : constant.var( dfeUInt(1), 1);

		DFEVar deriv = gate["deriv"];
		DFEComplex zero = cplxTypeFix32.newInstance( this );
		zero.setReal( constant.var( dataTypeFix32, 0.0) );
		zero.setImaginary( constant.var( dataTypeFix32, 0.0) );

		x = deriv ? zero : x;
		x = ControlQubitState ?  transformedAmplitude : x;
//debug.simPrintf("%d ControlQubit: %d, %d\n", indexCounter, useControlQubit, ControlQubitState);


//debug.simPrintf("gate_idx: %d, elements c: %f, %f, %f, %d, target :%d\n", gate_idx, x.getReal(), transformedAmplitude.getReal(), kernelMatrix[2].getReal(), controlQubit, targetQubit);

}

		// Output
		io.output("y", x, cplxTypeFix32);


		// Calculate the real trace of the transformed unitary
		if (calcTrace==true) {

			DFEVar IterationNum   = io.scalarInput("IterationNum", dfeUInt(16) );
			DFEVar GateSetNum     = io.scalarInput("GateSetNum", dfeUInt(16) );

			CounterChain chain = control.count.makeCounterChain();
			DFEVar iterationIdx = chain.addCounter(IterationNum, 1);
			DFEVar gateSetIdx   = chain.addCounter(GateSetNum, 1);
			DFEVar colIdx       = chain.addCounter(dim, 1);
			DFEVar rowIdx       = chain.addCounter(dim, 1);


			DFEVar trace      = dataTypeFix64.newInstance(this);

			DFEVar addToTrace = colIdx===rowIdx ? x.getReal().cast(dataTypeFix64) : constant.var( dataTypeFix64, 0.0);
			optimization.pushNoPipelining();
			DFEVar prevTrace = (colIdx+rowIdx)===0 ? constant.var( dataTypeFix64, 0.0) : stream.offset(trace,-1);
			optimization.pushNoPipelining();

			trace <== prevTrace + addToTrace;
/*
if (verbose) {
//debug.simPrintf("trace: %f, %d\n", x.getReal(), colIdx===rowIdx);
debug.simPrintf("trace: %f, %f, %d, %d, %d, %d, %d\n", x.getReal(), trace, rowIdx, colIdx, iterationIdx, IterationNum, (rowIdx>=dim-2) & (colIdx===dim-1) & iterationIdx===IterationNum-1);
}
*/
			//output the last 2 elements to have 16bytes on the CPU stream
			io.output("trace", trace, dataTypeFix64, (rowIdx>=dim-2) & (colIdx===dim-1) & iterationIdx===IterationNum-1);

		}

	}

}
