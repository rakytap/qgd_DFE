package qgddfe;

import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface.Direction;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemInterface;
//import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemCommandGroup;

import com.maxeler.platform.max5.manager.ImplementationStrategy;
import com.maxeler.platform.max5.manager.BuildConfig;
//import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;

import com.maxeler.platform.max5.manager.XilinxAlveoU250Manager;;

/**
@brief ????????????
@return ??????????
*/
public class qgdDFEManager extends XilinxAlveoU250Manager {

	int dim = 1024;
	int dim_over_2 = dim/2;


/**
@brief ????????????
@return ??????????
*/
	public qgdDFEManager(EngineParameters params) {
		super(params);
		
		//getLMemGlobalConfig().setMemoryFrequency(LMemFrequency.LMEM_1200MHZ);
		getLMemGlobalConfig().setMcpFrequency( 250 ); //220
		LMemInterface iface = addLMemInterface("LMEMiface", XilinxAlveoU250Manager.NamedRegion.SLR0);

                /////////////////// CPU - LMEM communication ///////////////////////

                // memory command gererator kernels (mcg)
		final KernelBlock mcg_cpu2lmem_kernel = addKernel(new MemCommGeneratorKernel(makeKernelParameters("CPU2LMEMCommGenKernel"), 1, 0));
		final KernelBlock mcg_lmem2cpu_kernel = addKernel(new MemCommGeneratorKernel(makeKernelParameters("LMEM2CPUCommGenKernel"), 1, 0));
		final KernelBlock mcg_fromlmem_kernel = addKernel(new MemCommGeneratorKernel(makeKernelParameters("FromLMEMCommGenKernel"), 0, 1));
		final KernelBlock mcg_tolmem_kernel   = addKernel(new MemCommGeneratorKernel(makeKernelParameters("ToLMEMCommGenKernel"), 1, 0));
		assignToNamedRegion(mcg_cpu2lmem_kernel, XilinxAlveoU250Manager.NamedRegion.SLR0);
		assignToNamedRegion(mcg_lmem2cpu_kernel, XilinxAlveoU250Manager.NamedRegion.SLR0);
		assignToNamedRegion(mcg_fromlmem_kernel, XilinxAlveoU250Manager.NamedRegion.SLR0);
		assignToNamedRegion(mcg_tolmem_kernel, XilinxAlveoU250Manager.NamedRegion.SLR0);


		//DFELink cpu2lmem = iface.addStreamToLMem("cpu2lmem", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
		DFELink cpu2lmem = iface.addStreamToLMem("cpu2lmem", mcg_cpu2lmem_kernel.getOutput("cmdStream"));


		//DFELink lmem2cpu = iface.addStreamFromLMem("lmem2cpu", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
		DFELink lmem2cpu = iface.addStreamFromLMem("lmem2cpu", mcg_lmem2cpu_kernel.getOutput("cmdStream"));
		
		DFELink fromcpu = addStreamFromCPU("fromcpu");
		DFELink tocpu = addStreamToCPU("tocpu");
		cpu2lmem <== fromcpu;
		tocpu <== lmem2cpu;		

                /////////////////// Computing kernels ///////////////////////


		final KernelBlock gateKernel = addKernel(new GateKernelGeneratorKernel(makeKernelParameters("GateKernelGeneratorKernel"), dim));
		assignToNamedRegion(gateKernel, XilinxAlveoU250Manager.NamedRegion.SLR0);


		DFELink gatesFromCPU = addStreamFromCPU("gatesfromcpu");
		gateKernel.getInput("gatesCPU") <== gatesFromCPU;
           

		final KernelBlock kernel = addKernel(new qgdDFEKernel(makeKernelParameters("qgdDFEKernel"), dim));
		assignToNamedRegion(kernel, XilinxAlveoU250Manager.NamedRegion.SLR0);


		kernel.getInput("gates") <== gateKernel.getOutput("gatesDFE");
		


                // DFELink inA = iface.addStreamFromLMem("inA", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
		DFELink inA = iface.addStreamFromLMem("inA", mcg_fromlmem_kernel.getOutput("cmdStream"));

		//final DFELink x = addStreamFromCPU("x");
		kernel.getInput("x") <== inA;



                //DFELink outA = iface.addStreamToLMem("outA", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
		DFELink outA = iface.addStreamToLMem("outA", mcg_tolmem_kernel.getOutput("cmdStream"));
                

		//final DFELink y = addStreamToCPU("y");
		outA <== kernel.getOutput("y");



	}
	
/**
@brief ???????????
@param  
*/
	static EngineInterface interfaceDefault () {

		EngineInterface ei = new EngineInterface();

                // The number of comnponents in the wave-vector 
		InterfaceParam size  = ei.addParam("element_num", CPUTypes.INT32);
		InterfaceParam controlQubit = ei.addParam("controlQubit", CPUTypes.INT32);
		InterfaceParam targetQubit  = ei.addParam("targetQubit", CPUTypes.INT32);
		InterfaceParam dim          = ei.addParam("dim", CPUTypes.INT32);
		InterfaceParam gatesNum     = ei.addParam("gatesNum", CPUTypes.INT16);

		ei.setScalar("qgdDFEKernel", "dim", dim);
		ei.setScalar("qgdDFEKernel", "elementNum", dim*dim);

                // the overall size of the matrix
		InterfaceParam sizeInBytes = size * 2*CPUTypes.FLOAT.sizeInBytes();

                // starting address of LMEM
		InterfaceParam zero = ei.addConstant(0l);
//ei.setLMemLinear("inA", zero, sizeInBytes);
//ei.setLMemLinear("outA", sizeInBytes, sizeInBytes);
		
		// set parameters for the address generator kernel
		InterfaceParam burstSize = ei.addConstant(64);  //for single DIMM

		InterfaceParam burstNum = sizeInBytes/burstSize;
		InterfaceParam chunks = burstSize/(CPUTypes.FLOAT.sizeInBytes()*2);
		InterfaceParam ticksMax = burstNum*chunks*gatesNum;
		ei.setScalar("FromLMEMCommGenKernel", "IterationNum", gatesNum);
		ei.setScalar("FromLMEMCommGenKernel", "chunkNum", chunks);
		ei.setScalar("FromLMEMCommGenKernel", "burstNum", burstNum);
		ei.setScalar("FromLMEMCommGenKernel", "addrOffset", zero);
		ei.setScalar("FromLMEMCommGenKernel", "dynAddrOffset", burstNum);

		ei.setScalar("ToLMEMCommGenKernel", "IterationNum", gatesNum);
		ei.setScalar("ToLMEMCommGenKernel", "chunkNum", chunks);
		ei.setScalar("ToLMEMCommGenKernel", "burstNum", burstNum);
		ei.setScalar("ToLMEMCommGenKernel", "addrOffset", burstNum);

		//ei.setTicks("paramKernel", ei.addConstant(1l));

		ei.setTicks("GateKernelGeneratorKernel", gatesNum);
		ei.setTicks("qgdDFEKernel", ticksMax);
		ei.setTicks("FromLMEMCommGenKernel", ticksMax);
		ei.setTicks("ToLMEMCommGenKernel", ticksMax);
		ei.setTicks("CPU2LMEMCommGenKernel", zero);
		ei.setTicks("LMEM2CPUCommGenKernel", zero);

		ei.setLMemInterruptOn("outA");		
		//ei.setLMemInterruptOn("inA");	


		ei.ignoreStream("tocpu");		
		ei.ignoreStream("fromcpu");
                ei.ignoreLMem("cpu2lmem");
                ei.ignoreLMem("lmem2cpu");

		ei.ignoreLMem("inA");
		//ei.ignoreLMem("outA");

                ei.ignoreKernel("CPU2LMEMCommGenKernel");
                ei.ignoreKernel("LMEM2CPUCommGenKernel");


		return ei ;
	}	
	
	
/**
@brief ???????????
@param  
*/
	static EngineInterface interfaceWrite(String name) {
		EngineInterface ei = new EngineInterface(name);

		// The number of comnponents in the wave-vector 
		InterfaceParam size  = ei.addParam("element_num", CPUTypes.INT32);
	
		// the overall size of the matrix
		InterfaceParam sizeInBytes = size * CPUTypes.FLOAT.sizeInBytes();

                // starting address of LMEM
		InterfaceParam zero = ei.addConstant(0l);

		ei.setStream("fromcpu", CPUTypes.VOID, sizeInBytes );
		//ei.setLMemLinear("cpu2lmem", zero, sizeInBytes);


		// set parameters for the address generator kernel
		InterfaceParam burstSize = ei.addConstant(64);  //for single DIMM

		InterfaceParam burstNum = sizeInBytes/burstSize;
		InterfaceParam chunks = burstSize/(CPUTypes.FLOAT.sizeInBytes()*2);
		InterfaceParam ticksMax = burstNum*chunks;
		ei.setScalar("CPU2LMEMCommGenKernel", "IterationNum", ei.addConstant(1l));
		ei.setScalar("CPU2LMEMCommGenKernel", "chunkNum", chunks);
		ei.setScalar("CPU2LMEMCommGenKernel", "burstNum", burstNum);
		ei.setScalar("CPU2LMEMCommGenKernel", "addrOffset", zero);


		ei.setTicks("CPU2LMEMCommGenKernel", ticksMax);//ei.addConstant(1));
		ei.setTicks("LMEM2CPUCommGenKernel", zero);
		ei.setTicks("FromLMEMCommGenKernel", zero);
		ei.setTicks("ToLMEMCommGenKernel", zero);
		ei.setTicks("qgdDFEKernel", zero);
		ei.setTicks("GateKernelGeneratorKernel", zero);

		ei.setLMemInterruptOn("cpu2lmem");

		ei.ignoreAll(Direction.IN_OUT);

                // With custom memory address commenad generators it is needed to ignore other LMEM streams!!!!!!!!!!!!!!!!!!!!!
		ei.ignoreLMem("lmem2cpu");
		ei.ignoreLMem("inA");
		ei.ignoreLMem("outA");

		return ei;
	}


/**
@brief ???????????
@param  
*/
	static EngineInterface interfaceRead(String name) {
		EngineInterface ei = new EngineInterface(name);

		// The number of comnponents in the wave-vector 
		InterfaceParam size  = ei.addParam("element_num", CPUTypes.INT32);

		// the overall size of the matrix
		InterfaceParam sizeInBytes = size * CPUTypes.FLOAT.sizeInBytes();

                // starting address of LMEM
		//InterfaceParam zero = ei.addConstant(0l);

		//ei.setLMemLinear("lmem2cpu", sizeInBytes, sizeInBytes);
		ei.setStream("tocpu", CPUTypes.VOID, sizeInBytes);

                // set parameters for the address generator kernel
                InterfaceParam burstSize = ei.addConstant(64);  //for single DIMM
		InterfaceParam burstNum = sizeInBytes/burstSize;
		InterfaceParam chunks = burstSize/(CPUTypes.FLOAT.sizeInBytes()*2);
		InterfaceParam ticksMax = burstNum*chunks;
		ei.setScalar("LMEM2CPUCommGenKernel", "IterationNum", ei.addConstant(1l));
                ei.setScalar("LMEM2CPUCommGenKernel", "burstNum", burstNum);
                ei.setScalar("LMEM2CPUCommGenKernel", "addrOffset", burstNum);
                ei.setScalar("LMEM2CPUCommGenKernel", "chunkNum", chunks);

                InterfaceParam zero = ei.addConstant(0l);
                ei.setTicks("LMEM2CPUCommGenKernel", ticksMax);
                ei.setTicks("CPU2LMEMCommGenKernel", zero);
		ei.setTicks("FromLMEMCommGenKernel", zero);
		ei.setTicks("ToLMEMCommGenKernel", zero);
		ei.setTicks("qgdDFEKernel", zero);
		ei.setTicks("GateKernelGeneratorKernel", zero);

                ei.setLMemInterruptOn("lmem2cpu");

		ei.ignoreAll(Direction.IN_OUT);

                // With custom memory address commenad generators it is needed to ignore other LMEM streams!!!!!!!!!!!!!!!!!!!!!
		ei.ignoreLMem("cpu2lmem");
		ei.ignoreLMem("inA");
		ei.ignoreLMem("outA");

		return ei;
	}
	
		
/**
@brief ???????????
@param  
*/
	public static void main(final String[] argv) {		
		final EngineParameters params = new EngineParameters(argv);
		final qgdDFEManager manager = new qgdDFEManager(params);

		BuildConfig conf = manager.getBuildConfig();
/*
		conf.setImplementationStrategies(  	ImplementationStrategy.CONGESTION_SPREAD_LOGIC_HIGH,
 							ImplementationStrategy.CONGESTION_SPREAD_LOGIC_MEDIUM,
							ImplementationStrategy.VIVADO_DEFAULT, 
							ImplementationStrategy.MAXELER3,  
							ImplementationStrategy.PERFORMANCE_WL_BLOCK_PLACEMENT_FANOUT_OPT, 
							ImplementationStrategy.PERFORMANCE_NET_DELAY_HIGH );
*/
		conf.setImplementationStrategies(  ImplementationStrategy.VIVADO_DEFAULT );
		conf.setParallelism( 64 );

		manager.setDefaultStreamClockFrequency(350);



		manager.createSlicInterface(qgdDFEManager.interfaceDefault());
		manager.createSlicInterface(qgdDFEManager.interfaceWrite("writeLMem"));
		manager.createSlicInterface(qgdDFEManager.interfaceRead("readLMem"));

		
		manager.build();
	}

}
