package qgddfe;

import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface.Direction;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemInterface;
import com.maxeler.maxcompiler.v2.managers.custom.api.ManagerPCIe;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemGlobalConfig;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemConfig;
//import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemCommandGroup;

import com.maxeler.platform.max5.manager.ImplementationStrategy;
import com.maxeler.platform.max5.manager.BuildConfig;
//import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.managers.custom.api.ManagerRouting;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.Fanout;
import com.maxeler.maxcompiler.v2.managers.custom.ManagerClock;

import com.maxeler.platform.max5.manager.XilinxAlveoU250Manager;
import com.maxeler.conf.base.MaxCompilerBuildConf;

import com.maxeler.maxcompiler.v2.managers.custom.api.ManagerPCIe.StreamMode;
import com.maxeler.platform.max5.manager.SynthesisStrategy;

import java.util.ArrayList;
import java.util.List;
// phys_opt_design -slr_crossing_opt -tns_cleanup

/**
@brief ????????????
@return ??????????
*/
public class qgdDFEManager extends XilinxAlveoU250Manager {

	int dim = 512; //max 1024
	int dim_over_2 = dim/2;
	int burstCountOneShot = 100;
	static int chainedGatesNum = 6;
	static int gatesNumPerKernel = 17;
	static int totalGatesInChain = chainedGatesNum*gatesNumPerKernel;

/**
@brief ????????????
@return ??????????
*/
	public static void selectSLR(int slr_index, XilinxAlveoU250Manager owner) {
		XilinxAlveoU250Manager.NamedRegion[] availableRegions = XilinxAlveoU250Manager.NamedRegion.values();
		if (slr_index < 0 || slr_index >= availableRegions.length) {
			throw new IllegalArgumentException();
		}
			owner.pushNamedRegion(availableRegions[slr_index]);
	}

/**
@brief ????????????
@return ??????????
*/
	public static void unselectSLR(XilinxAlveoU250Manager owner) { owner.popRegion(); }
/**
@brief ????????????
@return ??????????
*/
	public static DFELink slrCrossingChain(String name, String suffix, DFELink input, int slrStart, int slrEnd, int regPerX, ManagerRouting owner) //-1 for PCIE
	{
		if (owner != null) {
			for (int i = slrStart + (slrEnd >= slrStart ? 1 : -1); slrEnd >= slrStart ? i < slrEnd : i > slrEnd; ) {
				selectSLR(i, (XilinxAlveoU250Manager)owner);
				Fanout fo = owner.fanout(name + "Fanout" + suffix + i);
				unselectSLR((XilinxAlveoU250Manager)owner);
				DFELink inp = fo.getInput();            
				inp.setAdditionalRegisters(regPerX);
				inp <== input;
				input = fo.addOutput(name + "Chain" + suffix + i);
				input.setAdditionalRegisters(regPerX);
				if (slrEnd >= slrStart) i++; else i--;
			}
		} else
			input.setAdditionalRegisters(regPerX * ((slrEnd >= slrStart) ? slrEnd - slrStart : slrStart - slrEnd));
		return input;
	}
	
	
	public static DFELink slrCrossingChainWithClock(String name, String suffix, DFELink input, int slrStart, int slrEnd, int regPerX, ManagerRouting owner, ManagerClock clock) //-1 for PCIE
	{
		if (owner != null) {
			for (int i = slrStart + (slrEnd >= slrStart ? 1 : -1); slrEnd >= slrStart ? i < slrEnd : i > slrEnd; ) {
				selectSLR(i, (XilinxAlveoU250Manager)owner);
				Fanout fo = owner.fanout(name + "Fanout" + suffix + i);
				fo.setClock( clock );
				unselectSLR((XilinxAlveoU250Manager)owner);
				DFELink inp = fo.getInput();            
				inp.setAdditionalRegisters(regPerX);
				inp <== input;
				input = fo.addOutput(name + "Chain" + suffix + i);
				input.setAdditionalRegisters(regPerX);
				if (slrEnd >= slrStart) i++; else i--;
			}
		} else
			input.setAdditionalRegisters(regPerX * ((slrEnd >= slrStart) ? slrEnd - slrStart : slrStart - slrEnd));
		return input;
	}	


/**
@brief ????????????
@return ??????????
*/
	public qgdDFEManager(EngineParameters params) {
		super(params);	

		// parameter to add additional registers for SLR crossing of data streams
		int regPerX = 4;
		int regPerX_LMEM = 5;		
		int regPerX_CPU = 4;
		
//pushFanoutLimit(24);
		
		
		//getLMemGlobalConfig().setMemoryFrequency(LMemFrequency.LMEM_1200MHZ);
		getLMemGlobalConfig().setMcpFrequency( 260 ); //220
		
		List<XilinxAlveoU250Manager.NamedRegion> named_region_list = new ArrayList<XilinxAlveoU250Manager.NamedRegion>();
		named_region_list.add( XilinxAlveoU250Manager.NamedRegion.SLR0 );
		named_region_list.add( XilinxAlveoU250Manager.NamedRegion.SLR1 );
		named_region_list.add( XilinxAlveoU250Manager.NamedRegion.SLR2 );
		named_region_list.add( XilinxAlveoU250Manager.NamedRegion.SLR3 );						
		
		List<LMemInterface> iface_list = new ArrayList<LMemInterface>();
		//List<LMemGlobalConfig.PriorityArbitrationType> priorityList = new ArrayList<LMemGlobalConfig.PriorityArbitrationType>();
		//priorityList.add( LMemGlobalConfig.PriorityArbitrationType.LOW );  // read stream
		//priorityList.add( LMemGlobalConfig.PriorityArbitrationType.LOW );  // read stream
		//priorityList.add( LMemGlobalConfig.PriorityArbitrationType.HIGH ); // write stream
		//priorityList.add( LMemGlobalConfig.PriorityArbitrationType.HIGH ); // write stream
		
                // memory command gererator kernels (mcg)
		List<KernelBlock> mcg_cpu2lmem_kernel_list = new ArrayList<KernelBlock>();
//		List<KernelBlock> mcg_lmem2cpu_kernel_list = new ArrayList<KernelBlock>();


		List<KernelBlock> mcg_fromlmem_kernel_list = new ArrayList<KernelBlock>();
		List<KernelBlock> mcg_tolmem_kernel_list = new ArrayList<KernelBlock>();
		
		List<DFELink> cpu2lmem_list = new ArrayList<DFELink>();	
//		List<DFELink> lmem2cpu_list = new ArrayList<DFELink>();
		
		
		List<KernelBlock> gateKernel_list = new ArrayList<KernelBlock>();
		List<KernelBlock> kernel_list = new ArrayList<KernelBlock>();	
		
		// slow clock region for gate and memory address generators
		ManagerClock slowClock = generateStaticClock("slowClock", 150);
		ManagerClock memoryClock = generateStaticClock("memoryClock", 250);	

                // kernels to split input data comming from CPU to SLRs
		pushNamedRegion(named_region_list[0]);
		KernelBlock gateDataSplitKernel = addKernel(new GateDataSplitKernel(makeKernelParameters("GateDataSplitKernel") ) );
		gateDataSplitKernel.setClock( slowClock );
		DFELink gatesDataCPU = gateDataSplitKernel.getInput( "gatesDataCPU" );
		gatesDataCPU.setAdditionalRegisters(regPerX);
		DFELink gatesfromcpu = addStreamFromCPU("gatesfromcpu");
		gatesfromcpu.setAdditionalRegisters(regPerX);
		gatesDataCPU <== gatesfromcpu;

		
		
		Fanout inputSplitter = fanout("inputSplitFanout");
		inputSplitter.setClock( slowClock );
		DFELink fromCPU = addStreamFromCPU("fromcpu");
		fromCPU.setAdditionalRegisters(regPerX);	
		DFELink inputSplitterStream = inputSplitter.getInput();
		inputSplitterStream.setAdditionalRegisters(regPerX);	
		inputSplitterStream <== fromCPU;


		KernelBlock traceMergeKernel = addKernel(new TraceMergeKernel(makeKernelParameters("TraceMergeKernel") ) );
		traceMergeKernel.setClock( slowClock );
		DFELink mergedTrace = traceMergeKernel.getOutput( "trace" );
		mergedTrace.setAdditionalRegisters(regPerX);
		DFELink trace2cpu = addStreamToCPU("trace2cpu");
		trace2cpu.setAdditionalRegisters(regPerX);
		trace2cpu <== mergedTrace;

		popRegion();				
		
		for( int idx=0; idx<4; idx++) {
		
		
			pushNamedRegion(named_region_list[idx]);
/*			
			// slow clock region for gate and memory address generators
			ManagerClock slowClock = generateStaticClock("slowClock_"+String.valueOf(idx), 150);
			ManagerClock memoryClock = generateStaticClock("memoryClock_"+String.valueOf(idx), 270);						
*/			
			// create memory interface			
			iface_list.add( addLMemInterface("LMEMiface_"+String.valueOf(idx), named_region_list[idx]) );
/*
			iface_list[idx].getLMemConfig().setArbitrationMode(LMemConfig.ArbitrationMode.PRIORITY);
			iface_list[idx].getLMemConfig().setPriorityArbitrationList(priorityList);
*/



	                /////////////////// CPU - LMEM communication ///////////////////////
			mcg_cpu2lmem_kernel_list.add( addKernel(new MemCommGeneratorKernel(makeKernelParameters("CPU2LMEMCommGenKernel_"+String.valueOf(idx)), 1, 1, burstCountOneShot, false)) );
//			mcg_lmem2cpu_kernel_list.add( addKernel(new MemCommGeneratorKernel(makeKernelParameters("LMEM2CPUCommGenKernel_"+String.valueOf(idx)), 1, 0, burstCountOneShot)) );
			mcg_cpu2lmem_kernel_list[idx].setClock( slowClock );


			mcg_fromlmem_kernel_list.add( addKernel(new MemCommGeneratorKernel(makeKernelParameters("FromLMEMCommGenKernel_"+String.valueOf(idx)), 0, 1, burstCountOneShot, idx==0)) );
			mcg_tolmem_kernel_list.add( addKernel(new MemCommGeneratorKernel(makeKernelParameters("ToLMEMCommGenKernel_"+String.valueOf(idx)), 1, 0, burstCountOneShot, false)) );
			mcg_fromlmem_kernel_list[idx].setClock( memoryClock );
			mcg_tolmem_kernel_list[idx].setClock( memoryClock );


			cpu2lmem_list.add( iface_list[idx].addStreamToLMem("cpu2lmem_"+String.valueOf(idx), mcg_cpu2lmem_kernel_list[idx].getOutput("cmdStream")) );
			
			
//			lmem2cpu_list.add( iface_list[idx].addStreamFromLMem("lmem2cpu_"+String.valueOf(idx), mcg_lmem2cpu_kernel_list[idx].getOutput("cmdStream")) );			
			
			DFELink FromFanout = inputSplitter.addOutput( "fromFanout_"+String.valueOf(idx));
			//DFELink FromCPU = addStreamFromCPU("fromcpu_"+String.valueOf(idx));// , StreamMode.LOW_LATENCY_ENABLED);
			FromFanout.setAdditionalRegisters(regPerX_CPU);
			
			popRegion();
			FromFanout = slrCrossingChainWithClock("inputfromcpu", Integer.toString(idx), FromFanout, -1, idx, regPerX, this, slowClock);		
			//FromCPU = slrCrossingChain("inputfromcpu", Integer.toString(idx), FromCPU, -1, idx, regPerX, this);					
			pushNamedRegion(named_region_list[idx]);
			
			cpu2lmem_list[idx].setAdditionalRegisters(regPerX_LMEM);			
			cpu2lmem_list[idx] <== FromFanout;
//			addStreamToCPU("tocpu_"+String.valueOf(idx)) <== lmem2cpu_list[idx];		
			
			
			/////////////////// Computing kernels ///////////////////////				

			gateKernel_list.add( addKernel(new GateKernelGeneratorKernel(makeKernelParameters("GateKernelGeneratorKernel_"+String.valueOf(idx)), dim, chainedGatesNum, gatesNumPerKernel, idx==0)) ); 
			gateKernel_list[idx].setClock( slowClock );
			
			DFELink gatesFromCPU = gateDataSplitKernel.getOutput("gatesDataCPUchunk_"+String.valueOf(idx)); //addStreamFromCPU("gatesfromcpu_"+String.valueOf(idx));//, StreamMode.LOW_LATENCY_ENABLED);
			gatesFromCPU.setAdditionalRegisters(regPerX);
			popRegion();
			gatesFromCPU = slrCrossingChainWithClock("gatesfromcpu", Integer.toString(idx), gatesFromCPU, -1, idx, regPerX, this, slowClock);		
			//gatesFromCPU = slrCrossingChain("gatesfromcpu", Integer.toString(idx), gatesFromCPU, -1, idx, regPerX, this);					
			pushNamedRegion(named_region_list[idx]);

			DFELink gatesCPU = gateKernel_list[idx].getInput("gatesCPU");	
			gatesCPU.setAdditionalRegisters(regPerX);
			gatesCPU <== gatesFromCPU;
			
			
			for (int gate_idx=0; gate_idx<chainedGatesNum; gate_idx++) {
				kernel_list.add( addKernel(new qgdDFEKernel(makeKernelParameters("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx)), dim, gatesNumPerKernel, gate_idx==chainedGatesNum-1, idx==0)) );
			}
		

			for (int gate_idx=0; gate_idx<chainedGatesNum; gate_idx++) {
				DFELink gatesDFE = gateKernel_list[idx].getOutput("gatesDFE_"+String.valueOf(gate_idx));
				gatesDFE.setAdditionalRegisters(regPerX+gate_idx);

				DFELink gatesInput = kernel_list[idx*chainedGatesNum+gate_idx].getInput("gates");
				gatesInput.setAdditionalRegisters(regPerX+gate_idx);
				gatesInput <== gatesDFE;
			}
					
			
			for (int gate_idx=0; gate_idx<chainedGatesNum; gate_idx++) {

				if ( gate_idx==0 ) {
					DFELink inA = iface_list[idx].addStreamFromLMem("inA_"+String.valueOf(idx), mcg_fromlmem_kernel_list[idx].getOutput("cmdStream"));
					inA.setAdditionalRegisters(regPerX_LMEM);
					DFELink x = kernel_list[idx*chainedGatesNum].getInput("x");
					x.setAdditionalRegisters(regPerX_LMEM);
					x <== inA;
				}
				else{
					DFELink outDFEKernel = kernel_list[idx*chainedGatesNum+gate_idx-1].getOutput("y");
					outDFEKernel.setAdditionalRegisters(regPerX);

					DFELink x = kernel_list[idx*chainedGatesNum+gate_idx].getInput("x");
					x.setAdditionalRegisters(regPerX);
					x <== outDFEKernel;

				}


				if ( gate_idx==chainedGatesNum-1 ) {
					DFELink outA = iface_list[idx].addStreamToLMem("outA_"+String.valueOf(idx), mcg_tolmem_kernel_list[idx].getOutput("cmdStream"));
					outA.setAdditionalRegisters(regPerX_LMEM);
					DFELink y = kernel_list[idx*chainedGatesNum+gate_idx].getOutput("y");
					y.setAdditionalRegisters(regPerX_LMEM);
                			outA <== y;

					DFELink trace2merge = traceMergeKernel.getInput( "trace_"+String.valueOf(idx));
					trace2merge.setAdditionalRegisters(regPerX_CPU);
					//DFELink trace2cpu = addStreamToCPU("trace2cpu_"+String.valueOf(idx));//, StreamMode.LOW_LATENCY_ENABLED);
					//trace2cpu.setAdditionalRegisters(regPerX_CPU);

					DFELink trace = kernel_list[idx*chainedGatesNum+gate_idx].getOutput("trace");				
					trace.setAdditionalRegisters(regPerX);

					popRegion();
					trace = slrCrossingChainWithClock("trace2cpu", Integer.toString(idx), trace, idx, -1, regPerX, this, slowClock);		
					//gatesFromCPU = slrCrossingChain("gatesfromcpu", Integer.toString(idx), gatesFromCPU, -1, idx, regPerX, this);					
					pushNamedRegion(named_region_list[idx]);


					trace2merge <== trace;
					//trace2cpu <== trace;
				}

			}							
			
			popRegion();


		}

					
                
		




	}
	
/**
@brief ???????????
@param  
*/
	static EngineInterface interfaceDefault () {

		EngineInterface ei = new EngineInterface();

                // The number of comnponents in the wave-vector 
		InterfaceParam rows         = ei.addParam("rows", CPUTypes.UINT32);
		InterfaceParam cols         = ei.addParam("cols", CPUTypes.UINT32);
		InterfaceParam size         = rows*cols;
		InterfaceParam gatesNum     = ei.addParam("gatesNum", CPUTypes.UINT16);

		//InterfaceParam gateSetNum     = ei.addParam("gateSetNum", CPUTypes.INT16);

		List<InterfaceParam> gateSetNum_list = new ArrayList<InterfaceParam>();		
		for (int idx=0; idx<4; idx++) {
			gateSetNum_list.add( ei.addParam("gateSetNum_"+String.valueOf(idx), CPUTypes.UINT64) );		
		}

		for( int idx=0; idx<4; idx++) {
			for (int gate_idx=0; gate_idx<chainedGatesNum; gate_idx++) {
				ei.setScalar("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), "rows", rows);
				ei.setScalar("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), "elementNum", size);

				if( gate_idx==chainedGatesNum-1) {
					ei.setScalar("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), "IterationNum", gatesNum/chainedGatesNum/gatesNumPerKernel);
					ei.setScalar("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), "GateSetNum", gateSetNum_list[idx]);
				        ei.setScalar("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), "cols", cols);
					//ei.setStream("trace2cpu_"+String.valueOf(idx), CPUTypes.VOID, 16*gateSetNum_list[idx] );
					//ei.setStream("trace2cpu_"+String.valueOf(idx), CPUTypes.VOID, 16*gateSetNum );
				}
			}
		}

                // the overall size of the matrix
		InterfaceParam sizeInBytes = size * 2*CPUTypes.FLOAT.sizeInBytes();

                // starting address of LMEM
		InterfaceParam zero = ei.addConstant(0l);
//ei.setLMemLinear("inA", zero, sizeInBytes);
//ei.setLMemLinear("outA", sizeInBytes, sizeInBytes);
		
		// set parameters for the address generator kernel
		InterfaceParam burstSize = ei.addConstant(64);  //for single DIMM

		InterfaceParam burstNum = sizeInBytes/burstSize;
		InterfaceParam chunks = burstSize/(CPUTypes.FLOAT.sizeInBytes()*2);
		//chunks = chunks; // in order to half down the operating frequency, only counting to the half of the number of chunks
		int LMEMtimeScale = 2;
		
		List<InterfaceParam> ticksMax_list = new ArrayList<InterfaceParam>();
		for (int idx=0; idx<4; idx++) {
			ticksMax_list.add( burstNum*chunks*gatesNum*gateSetNum_list[idx]/chainedGatesNum/gatesNumPerKernel );
		}

		//InterfaceParam ticksMax = burstNum*chunks*gatesNum*gateSetNum/chainedGatesNum;
		for( int idx=0; idx<4; idx++) {
//			ei.setScalar("FromLMEMCommGenKernel_"+String.valueOf(idx), "IterationNum", gatesNum/chainedGatesNum/gatesNumPerKernel);
			ei.setScalar("FromLMEMCommGenKernel_"+String.valueOf(idx), "dynAddrOffsetMax", burstNum*(gateSetNum_list[idx]-1));
			ei.setScalar("FromLMEMCommGenKernel_"+String.valueOf(idx), "chunkNum", chunks/LMEMtimeScale);
			ei.setScalar("FromLMEMCommGenKernel_"+String.valueOf(idx), "burstNum", burstNum);
			//ei.setScalar("FromLMEMCommGenKernel_"+String.valueOf(idx), "addrOffset", burstNum);
			//ei.setScalar("FromLMEMCommGenKernel_"+String.valueOf(idx), "dynAddrOffset", burstNum);

//			ei.setScalar("ToLMEMCommGenKernel_"+String.valueOf(idx), "IterationNum", gatesNum/chainedGatesNum/gatesNumPerKernel);
			ei.setScalar("ToLMEMCommGenKernel_"+String.valueOf(idx), "dynAddrOffsetMax", burstNum*(gateSetNum_list[idx]-1));
			ei.setScalar("ToLMEMCommGenKernel_"+String.valueOf(idx), "chunkNum", chunks/LMEMtimeScale);
			ei.setScalar("ToLMEMCommGenKernel_"+String.valueOf(idx), "burstNum", burstNum);
			//ei.setScalar("ToLMEMCommGenKernel_"+String.valueOf(idx), "addrOffset", burstNum);
			//ei.setScalar("ToLMEMCommGenKernel_"+String.valueOf(idx), "dynAddrOffset", burstNum);
		}

		//ei.setTicks("paramKernel", ei.addConstant(1l));


		for( int idx=0; idx<4; idx++) {
			for (int gate_idx=0; gate_idx<chainedGatesNum; gate_idx++) {
				ei.setTicks("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), ticksMax_list[idx]);
				//ei.setTicks("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), ticksMax);
			}
			ei.setTicks("FromLMEMCommGenKernel_"+String.valueOf(idx), ticksMax_list[idx]/LMEMtimeScale);
			ei.setTicks("ToLMEMCommGenKernel_"+String.valueOf(idx), ticksMax_list[idx]/LMEMtimeScale);
			//ei.setTicks("FromLMEMCommGenKernel_"+String.valueOf(idx), ticksMax);
			//ei.setTicks("ToLMEMCommGenKernel_"+String.valueOf(idx), ticksMax);
			ei.setTicks("CPU2LMEMCommGenKernel_"+String.valueOf(idx), zero);
//			ei.setTicks("LMEM2CPUCommGenKernel_"+String.valueOf(idx), zero);
			ei.setTicks("GateKernelGeneratorKernel_"+String.valueOf(idx), gatesNum*gateSetNum_list[idx]*4);			
			//ei.setTicks("GateKernelGeneratorKernel_"+String.valueOf(idx), gatesNum*gateSetNum);	
		}

		for( int idx=0; idx<4; idx++) {
			ei.setLMemInterruptOn("outA_"+String.valueOf(idx));
		}		

		//ei.setLMemInterruptOn("inA");	



		for( int idx=0; idx<4; idx++) {
			ei.ignoreLMem("inA_"+String.valueOf(idx));
		}
		//ei.ignoreLMem("outA");
		
		ei.ignoreStream("fromcpu");					

		for( int idx=0; idx<4; idx++) {
			ei.ignoreKernel("CPU2LMEMCommGenKernel_"+String.valueOf(idx));
//			ei.ignoreKernel("LMEM2CPUCommGenKernel_"+String.valueOf(idx));
			
//			ei.ignoreStream("tocpu_"+String.valueOf(idx));		
			//ei.ignoreStream("fromcpu_"+String.valueOf(idx));

			ei.ignoreLMem("cpu2lmem_"+String.valueOf(idx));
//			ei.ignoreLMem("lmem2cpu_"+String.valueOf(idx));			
		}

		ei.route("gatesfromcpuFanout10 -> gatesfromcpuChain10, " +
	            "gatesfromcpuFanout20->gatesfromcpuChain20, gatesfromcpuFanout21 -> gatesfromcpuChain21, " +
	            "gatesfromcpuFanout30 -> gatesfromcpuChain30, gatesfromcpuFanout31 -> gatesfromcpuChain31, gatesfromcpuFanout32 -> gatesfromcpuChain32, " + 
	            "inputfromcpuFanout10 -> inputfromcpuChain10, " +
	            "inputfromcpuFanout20->inputfromcpuChain20, inputfromcpuFanout21 -> inputfromcpuChain21, " +
	            "inputfromcpuFanout30 -> inputfromcpuChain30, inputfromcpuFanout31 -> inputfromcpuChain31, inputfromcpuFanout32 -> inputfromcpuChain32, " +
                    "trace2cpuFanout10 -> trace2cpuChain10, " +
	            "trace2cpuFanout20->trace2cpuChain20, trace2cpuFanout21 -> trace2cpuChain21, " +
	            "trace2cpuFanout30 -> trace2cpuChain30, trace2cpuFanout31 -> trace2cpuChain31, trace2cpuFanout32 -> trace2cpuChain32, " +
	            "inputSplitFanout -> fromFanout_0, inputSplitFanout -> fromFanout_1, inputSplitFanout -> fromFanout_2, inputSplitFanout -> fromFanout_3");		

		return ei ;
	}	
	
	
/**
@brief ???????????
@param  
*/
	static EngineInterface interfaceWrite(String name) {
		EngineInterface ei = new EngineInterface(name);

		// The number of comnponents in the wave-vector 
		InterfaceParam size  = ei.addParam("element_num", CPUTypes.INT32);
	
		// the overall size of the matrix
		InterfaceParam sizeInBytes = size * CPUTypes.FLOAT.sizeInBytes();

                // starting address of LMEM
		InterfaceParam zero = ei.addConstant(0l);

			ei.setStream("fromcpu", CPUTypes.VOID, sizeInBytes );
/*			
		for( int idx=0; idx<4; idx++) {
			ei.setStream("fromcpu_"+String.valueOf(idx), CPUTypes.VOID, sizeInBytes );
		}

*/
		// set parameters for the address generator kernel
		InterfaceParam burstSize = ei.addConstant(64);  //for single DIMM

		InterfaceParam burstNum = sizeInBytes/burstSize;
		InterfaceParam chunks = burstSize/(CPUTypes.FLOAT.sizeInBytes()*2);
		chunks = chunks/2; // in order to half down the operating frequency, only counting to the half of the number of chunks
		InterfaceParam ticksMax = burstNum*chunks;
		
		for( int idx=0; idx<4; idx++) {
//			ei.setScalar("CPU2LMEMCommGenKernel_"+String.valueOf(idx), "IterationNum", ei.addConstant(1l));
			ei.setScalar("CPU2LMEMCommGenKernel_"+String.valueOf(idx), "dynAddrOffsetMax", ei.addConstant(0l));
			ei.setScalar("CPU2LMEMCommGenKernel_"+String.valueOf(idx), "chunkNum", chunks);
			ei.setScalar("CPU2LMEMCommGenKernel_"+String.valueOf(idx), "burstNum", burstNum);
			//ei.setScalar("CPU2LMEMCommGenKernel_"+String.valueOf(idx), "addrOffset", zero);
		


			ei.setTicks("CPU2LMEMCommGenKernel_"+String.valueOf(idx), ticksMax);//ei.addConstant(1));
//			ei.setTicks("LMEM2CPUCommGenKernel_"+String.valueOf(idx), zero);
			ei.setTicks("FromLMEMCommGenKernel_"+String.valueOf(idx), zero);
			ei.setTicks("ToLMEMCommGenKernel_"+String.valueOf(idx), zero);
			for (int gate_idx=0; gate_idx<chainedGatesNum; gate_idx++) {
				ei.setTicks("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), zero);
			}
			ei.setTicks("GateKernelGeneratorKernel_"+String.valueOf(idx), zero);			
		}


		ei.setLMemInterruptOn("cpu2lmem_0");
		
		ei.route("gatesfromcpuFanout10 -> gatesfromcpuChain10, " +
	            "gatesfromcpuFanout20->gatesfromcpuChain20, gatesfromcpuFanout21 -> gatesfromcpuChain21, " +
	            "gatesfromcpuFanout30 -> gatesfromcpuChain30, gatesfromcpuFanout31 -> gatesfromcpuChain31, gatesfromcpuFanout32 -> gatesfromcpuChain32, " + 
	            "inputfromcpuFanout10 -> inputfromcpuChain10, " +
	            "inputfromcpuFanout20->inputfromcpuChain20, inputfromcpuFanout21 -> inputfromcpuChain21, " +
	            "inputfromcpuFanout30 -> inputfromcpuChain30, inputfromcpuFanout31 -> inputfromcpuChain31, inputfromcpuFanout32 -> inputfromcpuChain32, " +
	            "trace2cpuFanout10 -> trace2cpuChain10, " +
	            "trace2cpuFanout20->trace2cpuChain20, trace2cpuFanout21 -> trace2cpuChain21, " +
	            "trace2cpuFanout30 -> trace2cpuChain30, trace2cpuFanout31 -> trace2cpuChain31, trace2cpuFanout32 -> trace2cpuChain32, " +
	            "inputSplitFanout -> fromFanout_0, inputSplitFanout -> fromFanout_1, inputSplitFanout -> fromFanout_2, inputSplitFanout -> fromFanout_3");				

		ei.ignoreAll(Direction.IN_OUT);

                // With custom memory address commenad generators it is needed to ignore other LMEM streams!!!!!!!!!!!!!!!!!!!!!
		for( int idx=0; idx<4; idx++) {                
//			ei.ignoreLMem("lmem2cpu_"+String.valueOf(idx));
			ei.ignoreLMem("inA_"+String.valueOf(idx));
			ei.ignoreLMem("outA_"+String.valueOf(idx));
		}


		return ei;
	}


/**
@brief ???????????
@param  
*/
/*
	static EngineInterface interfaceRead(String name) {
		EngineInterface ei = new EngineInterface(name);

		// The number of comnponents in the wave-vector 
		InterfaceParam size  = ei.addParam("element_num", CPUTypes.INT32);

		// the overall size of the matrix
		InterfaceParam sizeInBytes = size * CPUTypes.FLOAT.sizeInBytes();

                // starting address of LMEM
		//InterfaceParam zero = ei.addConstant(0l);

		for( int idx=0; idx<4; idx++) {
			ei.setStream("tocpu_"+String.valueOf(idx), CPUTypes.VOID, sizeInBytes);
		}

                // set parameters for the address generator kernel
                InterfaceParam burstSize = ei.addConstant(64);  //for single DIMM
		InterfaceParam burstNum = sizeInBytes/burstSize;
		InterfaceParam chunks = burstSize/(CPUTypes.FLOAT.sizeInBytes()*2);
		InterfaceParam ticksMax = burstNum*chunks;
		
		InterfaceParam zero = ei.addConstant(0l);	
	
		
		for( int idx=0; idx<4; idx++) {
			ei.setScalar("LMEM2CPUCommGenKernel_"+String.valueOf(idx), "IterationNum", ei.addConstant(1l));
			ei.setScalar("LMEM2CPUCommGenKernel_"+String.valueOf(idx), "burstNum", burstNum);
			ei.setScalar("LMEM2CPUCommGenKernel_"+String.valueOf(idx), "addrOffset", burstNum);
//			ei.setScalar("LMEM2CPUCommGenKernel_"+String.valueOf(idx), "addrOffset", zero);	
			ei.setScalar("LMEM2CPUCommGenKernel_"+String.valueOf(idx), "chunkNum", chunks);
		


			ei.setTicks("LMEM2CPUCommGenKernel_"+String.valueOf(idx), ticksMax);
			ei.setTicks("CPU2LMEMCommGenKernel_"+String.valueOf(idx), zero);
			ei.setTicks("FromLMEMCommGenKernel_"+String.valueOf(idx), zero);
			ei.setTicks("ToLMEMCommGenKernel_"+String.valueOf(idx), zero);
			for (int gate_idx=0; gate_idx<chainedGatesNum; gate_idx++) {
				ei.setTicks("qgdDFEKernel_"+String.valueOf(idx)+"_"+String.valueOf(gate_idx), zero);
			}
			ei.setTicks("GateKernelGeneratorKernel_"+String.valueOf(idx), zero);
		}
		
		



		ei.setLMemInterruptOn("lmem2cpu_0");

		ei.ignoreAll(Direction.IN_OUT);

               // With custom memory address commenad generators it is needed to ignore other LMEM streams!!!!!!!!!!!!!!!!!!!!!
                
		for( int idx=0; idx<4; idx++) {                
			ei.ignoreLMem("cpu2lmem_"+String.valueOf(idx));
			ei.ignoreLMem("inA_"+String.valueOf(idx));
			ei.ignoreLMem("outA_"+String.valueOf(idx));
		}
		

		return ei;
	}
*/	
		
/**
@brief ???????????
@param  
*/
	public static void main(final String[] argv) {		
		final EngineParameters params = new EngineParameters(argv);
		final qgdDFEManager manager = new qgdDFEManager(params);

		BuildConfig conf = manager.getBuildConfig();

		conf.setOptimizationGoal(BuildConfig.OptimizationGoal.SPEED);
        	conf.setBuildEffort(BuildConfig.Effort.HIGH);
	        //conf.setImplementationNearMissRetries(1);
        	//conf.setImplementationNearMissThreshold(10000); //0-1000000 are considered within threshold for build success on MAX5
//conf.setBramMappingScaleFactor(0.5);

		conf.setImplementationStrategies( ImplementationStrategy.MAXELER4, 
						ImplementationStrategy.MAXELER3);
		conf.setSynthesisStrategy( SynthesisStrategy.FLOW_PERF_OPTIMIZED_HIGH );
		conf.setParallelism( 64 );

		manager.setDefaultStreamClockFrequency(350);
		



		manager.createSlicInterface(qgdDFEManager.interfaceDefault());
		manager.createSlicInterface(qgdDFEManager.interfaceWrite("writeLMem"));
//		manager.createSlicInterface(qgdDFEManager.interfaceRead("readLMem"));
//		manager.getBuildManager().setParameter(MaxCompilerBuildConf.build.clean_build_directory, false); //problematic for successful builds, but failed builds which have a timing score will get deleted...can manually delete dcp checkpoint files instead
		
		manager.addMaxFileConstant("CHAINED_GATES_NUM", qgdDFEManager.totalGatesInChain);	
		
		manager.build();
	}

}
